package generated_detection

import (
	"regexp"
	"strings"
)

// isJSorCSS checks if the extname indicates a filetype which is commonly minified?
func (d detector) isJSorCSS() bool {
	return d.hasExtension(".js") || d.hasExtension(".css")
}

// isMinified checks if the blob a minified file
//
// Considers a file minified if the average line length is greater then 110c
// Currently, only JS and CSS files are detected by this method.
func (d detector) isMinified() bool {
	if !d.isJSorCSS() || !d.Lines.HasLines() {
		return false
	}

	totalLineLength := 0

	for _, line := range d.Lines.All() {
		totalLineLength += len(line)
	}

	return totalLineLength / d.Lines.Len() > 110
}

// hasSourceMap checks if the blob contain a source-map reference
//
// We assume that if one of the last 2 lines starts with a source-map
// reference, then the current file was generated from other files.
func (d detector) hasSourceMap() bool {
	if !d.isJSorCSS() {
		return false
	}

	// We use the last 2 lines because the last line might be empty
	lines := d.Lines.Last(2)

	r := regexp.MustCompile("^[*][#@] source(?:Mapping)?URL|sourceURL=")
	for _, line := range lines {
		if r.MatchString(line) {
			return true
		}
	}

	return false
}

// isSourceMap checks if the blob is a generated source-map
//
// Source-maps usually have .css.map or .js.map extensions. In case they
// are not following the name convention, detect them based on the content.
func (d detector) isSourceMap() bool {
	if !strings.HasSuffix(d.FileName.Ext, ".map") {
		return false
	}

	nameR := regexp.MustCompile("(?i)(\\.css|\\.js)\\.map$")
	revision2R := regexp.MustCompile("^{\"version\":\\d+,")
	revision1R := regexp.MustCompile("^/\\*\\* Begin line maps\\. \\*\\*\\\\")

	if nameR.MatchString(d.FileName.Base) {
		return true
	}

	if !d.Lines.HasLines() {
		return false
	}

	firstLine := d.Lines.First(1)[0]

	return nameR.MatchString(d.FileName.Base) || revision2R.MatchString(firstLine) || revision1R.MatchString(firstLine)
}

// isCompiledCoffeeScript checks if the blob of JS was generated by CoffeeScript
//
// CoffeeScript is meant to output JS that would be difficult to
// tell if it was generated or not. Look for a number of patterns
// output by the CS compiler.
func (d detector) isCompiledCoffeeScript() bool {
	if !d.hasExtension(".js") || !d.Lines.HasLines() {
		return false
	}

	// CoffeeScript generated by > 1.2 include a comment on the first line
	coffeeScript12Re := regexp.MustCompile("^// Generated by ")
	firstLine := d.Lines.First(1)[0]

	if coffeeScript12Re.MatchString(firstLine) {
		return true
	}

	if d.isPotentiallyCoffeeScript() {
		varRe := regexp.MustCompile("var ")

		// Underscored temp vars are likely to be Coffee
		timesOneRe := regexp.MustCompile("(_fn|_i|_len|_ref|_results)")

		// bind and extend functions are very Coffee specific
		timesThreeRe := regexp.MustCompile("(__bind|__extends|__hasProp|__indexOf|__slice)")

		lines := d.Lines.All()

		score := 0
		for _, line := range lines {
			if varRe.MatchString(line) {
				timesOneMatch := timesOneRe.FindAllStringIndex(line, -1)
				timeThreeMatch := timesThreeRe.FindAllStringIndex(line, -1)

				score += len(timesOneMatch)
				score += len(timeThreeMatch) * 3
			}
		}

		// Require a score of 3. This is fairly arbitrary. Consider tweaking later.
		return score >= 3
	}

	return false
}

// isPotentiallyCoffeeScript tries to check if the script might have been generated by coffeescript
func (d detector) isPotentiallyCoffeeScript() bool {
	if d.Lines.Len() < 3 {
		return false
	}

	lastLines := d.Lines.Last(2)

	firstLine := d.Lines.First(1)[0]
	lastLine := lastLines[0]
	secondLastLine := lastLines[1]

	// First line is module closure opening
	// Second to last line closes module closure
	// Last line is blank
	return firstLine == "(function() {" && secondLastLine == "}).call(this);" && lastLine == ""
}
